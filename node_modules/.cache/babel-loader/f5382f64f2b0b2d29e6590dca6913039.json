{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-nocheck\n\nvar fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nvar react_1 = require(\"react\");\n\nvar use_ssr_1 = __importDefault(require(\"use-ssr\"));\n\nvar urs_1 = __importDefault(require(\"urs\"));\n\nvar types_1 = require(\"./types\");\n\nvar useFetchArgs_1 = __importDefault(require(\"./useFetchArgs\"));\n\nvar doFetchArgs_1 = __importDefault(require(\"./doFetchArgs\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar cache_1 = __importDefault(require(\"./cache\"));\n\nvar CACHE_FIRST = types_1.CachePolicies.CACHE_FIRST,\n    NO_CACHE = types_1.CachePolicies.NO_CACHE,\n    SWR = types_1.CachePolicies.SWR; // useSWR's mutate function\n\nvar setCache = function (reqID, _data, shouldRevalidate) {\n  if (shouldRevalidate === void 0) {\n    shouldRevalidate = true;\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var cache, data, error, err_1, err_2;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!reqID) return [2\n          /*return*/\n          ];\n          cache = cache_1.default.getLocalCache(reqID); // if there is no new data, call revalidate against the reqID\n\n          if (typeof _data === 'undefined') {\n            // return cache.listeners.forEach((l, i) => cache.notify(shouldRevalidate, cache.data, cache.error, i > 0))\n            return [2\n            /*return*/\n            , cache.notify(function (listener, i) {\n              return listener(shouldRevalidate, cache.data, cache.error, i > 0);\n            })];\n          }\n\n          if (!(_data && typeof _data === 'function')) return [3\n          /*break*/\n          , 5];\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , _data(cache.data)];\n\n        case 2:\n          data = _a.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          err_1 = _a.sent();\n          error = err_1;\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [3\n          /*break*/\n          , 11];\n\n        case 5:\n          if (!(_data && typeof _data.then === 'function')) return [3\n          /*break*/\n          , 10];\n          _a.label = 6;\n\n        case 6:\n          _a.trys.push([6, 8,, 9]);\n\n          return [4\n          /*yield*/\n          , _data];\n\n        case 7:\n          data = _a.sent();\n          return [3\n          /*break*/\n          , 9];\n\n        case 8:\n          err_2 = _a.sent();\n          error = err_2;\n          return [3\n          /*break*/\n          , 9];\n\n        case 9:\n          return [3\n          /*break*/\n          , 11];\n\n        case 10:\n          data = _data;\n          _a.label = 11;\n\n        case 11:\n          if (typeof data !== 'undefined') {\n            // update cached data, avoid notifying from the cache\n            cache.set(data, false);\n          } // update existing SWR Hooks' state\n\n\n          cache.notify(function (listener, i) {\n            return listener(shouldRevalidate, data, error, i > 0);\n          }); // throw error or return data to be used by caller of mutate\n\n          if (error) throw error;\n          return [2\n          /*return*/\n          , data];\n      }\n    });\n  });\n};\n\nfunction useFetch() {\n  var _this = this;\n\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var _a = useFetchArgs_1.default.apply(void 0, args),\n      host = _a.host,\n      path = _a.path,\n      customOptions = _a.customOptions,\n      requestInit = _a.requestInit,\n      dependencies = _a.dependencies;\n\n  var reqID = path;\n\n  var cacheLife = customOptions.cacheLife,\n      cachePolicy = customOptions.cachePolicy,\n      // 'stale-while-revalidate' by default\n  initialData = customOptions.initialData,\n      interceptors = customOptions.interceptors,\n      lazy = customOptions.lazy,\n      onAbort = customOptions.onAbort,\n      onError = customOptions.onError,\n      onNewData = customOptions.onNewData,\n      onTimeout = customOptions.onTimeout,\n      perPage = customOptions.perPage,\n      persist = customOptions.persist,\n      responseType = customOptions.responseType,\n      retries = customOptions.retries,\n      retryDelay = customOptions.retryDelay,\n      retryOn = customOptions.retryOn,\n      suspense = customOptions.suspense,\n      timeout = customOptions.timeout,\n      debug = customOptions.debug,\n      defaults = __rest(customOptions, [\"cacheLife\", \"cachePolicy\", \"initialData\", \"interceptors\", \"lazy\", \"onAbort\", \"onError\", \"onNewData\", \"onTimeout\", \"perPage\", \"persist\", \"responseType\", \"retries\", \"retryDelay\", \"retryOn\", \"suspense\", \"timeout\", \"debug\"]);\n\n  react_1.useEffect(function () {\n    cache_1.default.configure(reqID, {\n      persist: persist,\n      cachePolicy: cachePolicy,\n      cacheLife: cacheLife\n    });\n  }, [reqID, persist, cachePolicy, cacheLife]);\n  var cache = cache_1.default.getLocalCache(reqID);\n  var x = reqID + \" (\" + debug + \"): \"; // if a state is accessed (data, error or isValidating),\n  // we add the state to dependencies so if the state is\n  // updated in the future, we can trigger a rerender\n  // const stateDependencies = useRef({\n  //   data: false,\n  //   error: false,\n  //   isValidating: false\n  // })\n  // const stateRef = useRef({\n  //   data: initialData,\n  //   error: initialError,\n  //   isValidating: false\n  // })\n  // const rerender = useReducer(() => ({}), [])[1]\n  // let dispatch = useCallback(payload => {\n  //   let shouldUpdateState = false\n  //   for (let k in payload) {\n  //     stateRef.current[k] = payload[k]\n  //     if (stateDependencies.current[k]) {\n  //       shouldUpdateState = true\n  //     }\n  //   }\n  //   if (shouldUpdateState || suspense) {\n  //     rerender()\n  //   }\n  // }, [])\n  // useEffect(() => {\n  //   if (!reqID) return\n  // }, [])\n\n  var isServer = use_ssr_1.default().isServer;\n  var controller = react_1.useRef();\n  var attempt = react_1.useRef(0);\n  var error = react_1.useRef();\n  var hasMore = react_1.useRef(true);\n  var suspenseStatus = react_1.useRef('pending');\n  var suspender = react_1.useRef();\n  var mounted = react_1.useRef(false);\n  var expiration = react_1.useRef(Date.now() + cacheLife);\n\n  var _b = urs_1.default(cache.data),\n      data = _b[0],\n      setData = _b[1];\n\n  var _c = urs_1.default(defaults.loading),\n      loading = _c[0],\n      setLoading = _c[1];\n\n  var rerender = react_1.useReducer(function () {\n    return {};\n  }, [])[1]; // for react-native, could use https://www.npmjs.com/package/sync-storage\n  // if ([CACHE_FIRST, SWR].includes(cachePolicy) && cache.has(reqID)) {\n  //   console.log(x, 'setting data.current on rerender')\n  //   data.current = cache.get(reqID)\n  // }\n\n  var block = cachePolicy === NO_CACHE;\n  var makeFetch = utils_1.useDeepCallback(function (method, isBlocking) {\n    // let prevDedupeID\n    // let prevController\n    if (isBlocking === void 0) {\n      isBlocking = block;\n    }\n\n    var doFetch = function (routeOrBody, body) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var theController, _a, url, options, newData, newError, newRes, timer, timedout, promise, _b, opts, shouldRetry, _c, _d, theResponse, err_3, opts, shouldRetry, _e, _f, res;\n\n        return __generator(this, function (_g) {\n          switch (_g.label) {\n            case 0:\n              if (isServer) return [2\n              /*return*/\n              ]; // for now, we don't do anything on the server\n              // const dedupeID = path + route + ':' + method\n              // if (prevDedupeID === dedupeID && 'abort' in prevController) prevController.abort()\n              // prevDedupeID = dedupeID\n              // controller.current = prevController = new AbortController()\n\n              controller.current = new AbortController();\n              controller.current.signal.onabort = onAbort;\n              theController = controller.current;\n              return [4\n              /*yield*/\n              , doFetchArgs_1.default(requestInit, method, theController, host, path, routeOrBody, body, interceptors.request)];\n\n            case 1:\n              _a = _g.sent(), url = _a.url, options = _a.options;\n              timedout = false;\n              console.log(\"==== \" + x + \" ====\", cache.has(reqID)); // don't perform the request if there is no more data to fetch (pagination)\n\n              if (perPage > 0 && !hasMore.current && !error.current) return [2\n              /*return*/\n              , data.current];\n              _g.label = 2;\n\n            case 2:\n              _g.trys.push([2, 17, 23, 24]);\n\n              if (!(cache.has(reqID) && !cache.isStale && !isBlocking && [CACHE_FIRST, SWR].includes(cachePolicy))) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , cache.get(reqID) // newData = await cache.get(reqID)\n              // console.log(`${x} (doFetch) newData`, newData)\n              ];\n\n            case 3:\n              newData = _g.sent();\n              return [3\n              /*break*/\n              , 16];\n\n            case 4:\n              if (!suspense && !lazy && cachePolicy !== SWR) setLoading(true);\n              timer = timeout && setTimeout(function () {\n                timedout = true;\n                theController.abort();\n                if (onTimeout) onTimeout();\n              }, timeout);\n              promise = fetch(url, options);\n\n              if ([CACHE_FIRST, SWR].includes(cachePolicy)) {\n                cache.promise = promise;\n              }\n\n              return [4\n              /*yield*/\n              , promise];\n\n            case 5:\n              newRes = _g.sent();\n              return [4\n              /*yield*/\n              , utils_1.tryGetData(newRes, initialData, responseType)];\n\n            case 6:\n              newData = _g.sent();\n              newRes.data = onNewData(data.current, newData);\n              if (!interceptors.response) return [3\n              /*break*/\n              , 8];\n              return [4\n              /*yield*/\n              , interceptors.response({\n                response: newRes\n              })];\n\n            case 7:\n              _b = _g.sent();\n              return [3\n              /*break*/\n              , 9];\n\n            case 8:\n              _b = newRes;\n              _g.label = 9;\n\n            case 9:\n              newRes = _b;\n              newData = newRes.data;\n              utils_1.invariant('data' in newRes, 'You must have `data` field on the Response returned from your `interceptors.response`');\n              opts = {\n                attempt: attempt.current,\n                response: newRes\n              }; // if we just have `retries` set with NO `retryOn` then\n              // automatically retry on fail until attempts run out\n\n              _c = !utils_1.isFunction(retryOn) && Array.isArray(retryOn) && retryOn.length < 1 && (newRes === null || newRes === void 0 ? void 0 : newRes.ok) === false // otherwise only retry when is specified\n              || Array.isArray(retryOn) && retryOn.includes(newRes.status);\n              if (_c) // if we just have `retries` set with NO `retryOn` then\n                // automatically retry on fail until attempts run out\n                return [3\n                /*break*/\n                , 12];\n              _d = utils_1.isFunction(retryOn);\n              if (!_d) return [3\n              /*break*/\n              , 11];\n              return [4\n              /*yield*/\n              , retryOn(opts)];\n\n            case 10:\n              _d = _g.sent();\n              _g.label = 11;\n\n            case 11:\n              _c = _d;\n              _g.label = 12;\n\n            case 12:\n              shouldRetry = _c && retries > 0 && retries > attempt.current;\n              if (!shouldRetry) return [3\n              /*break*/\n              , 14];\n              return [4\n              /*yield*/\n              , retry(opts, routeOrBody, body)];\n\n            case 13:\n              theResponse = _g.sent();\n              return [2\n              /*return*/\n              , theResponse];\n\n            case 14:\n              if (Array.isArray(newData) && !!(newData.length % perPage)) hasMore.current = false;\n              if (!([CACHE_FIRST, SWR].includes(cachePolicy) && !utils_1.isEmpty(newData))) return [3\n              /*break*/\n              , 16];\n              return [4\n              /*yield*/\n              , cache.set(newData, false)];\n\n            case 15:\n              _g.sent();\n\n              _g.label = 16;\n\n            case 16:\n              return [3\n              /*break*/\n              , 24];\n\n            case 17:\n              err_3 = _g.sent();\n              console.log('ERR', err_3);\n              if (attempt.current >= retries && timedout) newError = utils_1.makeError('AbortError', 'Timeout Error');\n              opts = {\n                attempt: attempt.current,\n                error: err_3\n              }; // if we just have `retries` set with NO `retryOn` then\n              // automatically retry on fail until attempts run out\n\n              _e = !utils_1.isFunction(retryOn) && Array.isArray(retryOn) && retryOn.length < 1;\n              if (_e) // if we just have `retries` set with NO `retryOn` then\n                // automatically retry on fail until attempts run out\n                return [3\n                /*break*/\n                , 20];\n              _f = utils_1.isFunction(retryOn);\n              if (!_f) return [3\n              /*break*/\n              , 19];\n              return [4\n              /*yield*/\n              , retryOn(opts)];\n\n            case 18:\n              _f = _g.sent();\n              _g.label = 19;\n\n            case 19:\n              _e = _f;\n              _g.label = 20;\n\n            case 20:\n              shouldRetry = _e && retries > 0 && retries > attempt.current;\n              if (!shouldRetry) return [3\n              /*break*/\n              , 22];\n              return [4\n              /*yield*/\n              , retry(opts, routeOrBody, body)];\n\n            case 21:\n              res = _g.sent();\n              return [2\n              /*return*/\n              , res];\n\n            case 22:\n              if (err_3.name !== 'AbortError') newError = utils_1.makeError(err_3.name, err_3.message);\n              return [3\n              /*break*/\n              , 24];\n\n            case 23:\n              timedout = false;\n              if (timer) clearTimeout(timer);\n              controller.current = undefined;\n              return [7\n              /*endfinally*/\n              ];\n\n            case 24:\n              if (newRes && !newRes.ok && !newError) newError = utils_1.makeError(newRes.status, newRes.statusText);\n              if (!suspense && !lazy && cachePolicy !== SWR) setLoading(false);\n              if (attempt.current === retries) attempt.current = 0;\n              if (newError) onError({\n                error: newError\n              });\n              error.current = newError;\n              return [2\n              /*return*/\n              , {\n                options: options,\n                data: newData,\n                error: newError,\n                path: reqID,\n                ok: (newRes === null || newRes === void 0 ? void 0 : newRes.ok) === true,\n                status: newRes === null || newRes === void 0 ? void 0 : newRes.status,\n                statusText: newRes === null || newRes === void 0 ? void 0 : newRes.statusText\n              }];\n          }\n        });\n      });\n    }; // end of doFetch()\n\n\n    var retry = function (opts, routeOrBody, body) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var delay, res;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              delay = utils_1.isFunction(retryDelay) ? retryDelay(opts) : retryDelay;\n\n              if (!(Number.isInteger(delay) && delay >= 0)) {\n                console.error('retryDelay must be a number >= 0! If you\\'re using it as a function, it must also return a number >= 0.');\n              }\n\n              attempt.current++;\n              if (!delay) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , utils_1.sleep(delay)];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              return [4\n              /*yield*/\n              , doFetch(routeOrBody, body)];\n\n            case 3:\n              res = _a.sent();\n              return [2\n              /*return*/\n              , res];\n          }\n        });\n      });\n    };\n\n    if (suspense) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return __awaiter(_this, void 0, void 0, function () {\n          var res;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                suspender.current = doFetch.apply(void 0, args).then(function (newData) {\n                  suspenseStatus.current = 'success';\n                  return newData;\n                }, function () {\n                  suspenseStatus.current = 'error';\n                });\n                return [4\n                /*yield*/\n                , suspender.current];\n\n              case 1:\n                res = _a.sent();\n                rerender();\n                return [2\n                /*return*/\n                , res];\n            }\n          });\n        });\n      };\n    }\n\n    return doFetch;\n  }, [isServer, onAbort, requestInit, host, path, interceptors, cachePolicy, perPage, timeout, persist, cacheLife, onTimeout, defaults.data, onNewData, rerender, suspense]);\n  var post = react_1.useCallback(makeFetch(types_1.HTTPMethod.POST, true), [makeFetch]);\n  var request = react_1.useMemo(function () {\n    return {\n      get: makeFetch(types_1.HTTPMethod.GET, true),\n      post: post,\n      patch: makeFetch(types_1.HTTPMethod.PATCH, true),\n      put: makeFetch(types_1.HTTPMethod.PUT, true),\n      delete: makeFetch(types_1.HTTPMethod.DELETE, true),\n      abort: function () {\n        return controller.current && controller.current.abort();\n      },\n      query: function (query, variables) {\n        return post({\n          query: query,\n          variables: variables\n        });\n      },\n      mutate: function (mutation, variables) {\n        return post({\n          mutation: mutation,\n          variables: variables\n        });\n      },\n      loading: loading.current,\n      error: error.current\n    };\n  }, [makeFetch, loading.current, error.current]);\n\n  var revalidate = function () {};\n\n  var setDataRevalidate = react_1.useCallback(function (dataOrFn, shouldRevalidate) {\n    if (shouldRevalidate === void 0) {\n      shouldRevalidate = true;\n    }\n\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        // if (currentResponse.isCached)\n        data.current = utils_1.isFunction(dataOrFn) ? dataOrFn(data.current) : dataOrFn; // this will need to trigger the other components with this\n        // route to re-run their non-lazy useFetch requests\n\n        if (shouldRevalidate) {// TODO: revalidation\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  }, []); // onMount/onUpdate\n\n  react_1.useEffect(function () {\n    // if (Array.isArray(dependencies) || !mounted.current) {\n    (function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var methodName, req, newData;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              methodName = requestInit.method || types_1.HTTPMethod.GET;\n              req = makeFetch(methodName);\n              return [4\n              /*yield*/\n              , req()];\n\n            case 1:\n              newData = _a.sent().data;\n              console.log(x + \" data.current\", data.current);\n              console.log(x + \" newData\", newData);\n\n              if (!fast_deep_equal_1.default(newData, data.current)) {\n                if (loading.current) {\n                  data.current = newData;\n                } else {\n                  setData(newData);\n                }\n              }\n\n              if (loading.current) setLoading(false); // cache.errors[reqID] = error\n\n              mounted.current = true;\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    })();\n\n    console.log(x + \" useEffect data.current\", data.current);\n    console.log(x + \" mounted.current\", mounted.current); // }\n    // const currentData = data.current\n    // const initialData = cache.get(reqID) || defaults.initialData \n    // console.log('currentData', currentData)\n    // console.log('initialData', initialData)\n    // if (!isEqual(data.current, cache.get(reqID))) {\n    //   setData(cache.get(reqID))\n    // }\n    // register global cache update listener\n\n    var updateListener = function (shouldRevalidate, updatedData, updatedError, dedupe) {\n      if (shouldRevalidate === void 0) {\n        shouldRevalidate = true;\n      }\n\n      if (dedupe === void 0) {\n        dedupe = true;\n      } // update hook state\n\n\n      var newState = {};\n      var needUpdate = false;\n\n      if (typeof updatedData !== 'undefined' && !fast_deep_equal_1.default(data.current, updatedData)) {\n        newState.data = updatedData;\n        needUpdate = true;\n      } // always update error\n      // because it can be `undefined`\n      // if (stateRef.current.error !== updatedError) {\n      //   newState.error = updatedError\n      //   needUpdate = true\n      // }\n\n\n      if (needUpdate) {\n        setData(newState.data); // dispatch(newState)\n      }\n\n      if (shouldRevalidate) {\n        // if (dedupe) {\n        //   return softRevalidate()\n        // } else {\n        return revalidate(); // }\n      }\n\n      return false;\n    }; // add updater to listeners\n\n\n    cache.subscribe(updateListener); // if (!cache.revalidators[reqID]) {\n    //   cache.revalidators[reqID] = [updateListener]\n    // } else {\n    //   // cache.revalidators[reqID].push(updateListener)\n    // }\n\n    return function () {\n      mounted.current = false;\n      cache.unsubscribe(updateListener); // remove(onUpdate).from(cache.revalidators[key])\n    };\n  }, [makeFetch, reqID]);\n\n  if (suspense && suspender.current) {\n    if (isServer) throw new Error('Suspense on server side is not yet supported! 🙅‍♂️');\n\n    switch (suspenseStatus.current) {\n      case 'pending':\n        throw suspender.current;\n\n      case 'error':\n        throw error.current;\n    }\n  }\n\n  console.log(x + \" END cache\", cache);\n  console.log(x + \" END cache.data\", cache.data);\n  console.log(x + \" END data.current\", data.current);\n  return Object.assign([data.current, setDataRevalidate, request], __assign(__assign({\n    request: request,\n    setDataRevalidate: setDataRevalidate\n  }, request), {\n    loading: loading.current,\n    data: data.current,\n    error: error.current\n  }));\n}\n\nexports.useFetch = useFetch;\nexports.default = useFetch;","map":{"version":3,"sources":["../src/useFetch.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nvar fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nvar react_1 = require(\"react\");\nvar use_ssr_1 = __importDefault(require(\"use-ssr\"));\nvar urs_1 = __importDefault(require(\"urs\"));\nvar types_1 = require(\"./types\");\nvar useFetchArgs_1 = __importDefault(require(\"./useFetchArgs\"));\nvar doFetchArgs_1 = __importDefault(require(\"./doFetchArgs\"));\nvar utils_1 = require(\"./utils\");\nvar cache_1 = __importDefault(require(\"./cache\"));\nvar CACHE_FIRST = types_1.CachePolicies.CACHE_FIRST, NO_CACHE = types_1.CachePolicies.NO_CACHE, SWR = types_1.CachePolicies.SWR;\n// useSWR's mutate function\nvar setCache = function (reqID, _data, shouldRevalidate) {\n    if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var cache, data, error, err_1, err_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!reqID)\n                        return [2 /*return*/];\n                    cache = cache_1.default.getLocalCache(reqID);\n                    // if there is no new data, call revalidate against the reqID\n                    if (typeof _data === 'undefined') {\n                        // return cache.listeners.forEach((l, i) => cache.notify(shouldRevalidate, cache.data, cache.error, i > 0))\n                        return [2 /*return*/, cache.notify(function (listener, i) { return listener(shouldRevalidate, cache.data, cache.error, i > 0); })];\n                    }\n                    if (!(_data && typeof _data === 'function')) return [3 /*break*/, 5];\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, _data(cache.data)];\n                case 2:\n                    data = _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    error = err_1;\n                    return [3 /*break*/, 4];\n                case 4: return [3 /*break*/, 11];\n                case 5:\n                    if (!(_data && typeof _data.then === 'function')) return [3 /*break*/, 10];\n                    _a.label = 6;\n                case 6:\n                    _a.trys.push([6, 8, , 9]);\n                    return [4 /*yield*/, _data];\n                case 7:\n                    data = _a.sent();\n                    return [3 /*break*/, 9];\n                case 8:\n                    err_2 = _a.sent();\n                    error = err_2;\n                    return [3 /*break*/, 9];\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    data = _data;\n                    _a.label = 11;\n                case 11:\n                    if (typeof data !== 'undefined') {\n                        // update cached data, avoid notifying from the cache\n                        cache.set(data, false);\n                    }\n                    // update existing SWR Hooks' state\n                    cache.notify(function (listener, i) { return listener(shouldRevalidate, data, error, i > 0); });\n                    // throw error or return data to be used by caller of mutate\n                    if (error)\n                        throw error;\n                    return [2 /*return*/, data];\n            }\n        });\n    });\n};\nfunction useFetch() {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var _a = useFetchArgs_1.default.apply(void 0, args), host = _a.host, path = _a.path, customOptions = _a.customOptions, requestInit = _a.requestInit, dependencies = _a.dependencies;\n    var reqID = path;\n    var cacheLife = customOptions.cacheLife, cachePolicy = customOptions.cachePolicy, // 'stale-while-revalidate' by default\n    initialData = customOptions.initialData, interceptors = customOptions.interceptors, lazy = customOptions.lazy, onAbort = customOptions.onAbort, onError = customOptions.onError, onNewData = customOptions.onNewData, onTimeout = customOptions.onTimeout, perPage = customOptions.perPage, persist = customOptions.persist, responseType = customOptions.responseType, retries = customOptions.retries, retryDelay = customOptions.retryDelay, retryOn = customOptions.retryOn, suspense = customOptions.suspense, timeout = customOptions.timeout, debug = customOptions.debug, defaults = __rest(customOptions, [\"cacheLife\", \"cachePolicy\", \"initialData\", \"interceptors\", \"lazy\", \"onAbort\", \"onError\", \"onNewData\", \"onTimeout\", \"perPage\", \"persist\", \"responseType\", \"retries\", \"retryDelay\", \"retryOn\", \"suspense\", \"timeout\", \"debug\"]);\n    react_1.useEffect(function () {\n        cache_1.default.configure(reqID, { persist: persist, cachePolicy: cachePolicy, cacheLife: cacheLife });\n    }, [reqID, persist, cachePolicy, cacheLife]);\n    var cache = cache_1.default.getLocalCache(reqID);\n    var x = reqID + \" (\" + debug + \"): \";\n    // if a state is accessed (data, error or isValidating),\n    // we add the state to dependencies so if the state is\n    // updated in the future, we can trigger a rerender\n    // const stateDependencies = useRef({\n    //   data: false,\n    //   error: false,\n    //   isValidating: false\n    // })\n    // const stateRef = useRef({\n    //   data: initialData,\n    //   error: initialError,\n    //   isValidating: false\n    // })\n    // const rerender = useReducer(() => ({}), [])[1]\n    // let dispatch = useCallback(payload => {\n    //   let shouldUpdateState = false\n    //   for (let k in payload) {\n    //     stateRef.current[k] = payload[k]\n    //     if (stateDependencies.current[k]) {\n    //       shouldUpdateState = true\n    //     }\n    //   }\n    //   if (shouldUpdateState || suspense) {\n    //     rerender()\n    //   }\n    // }, [])\n    // useEffect(() => {\n    //   if (!reqID) return\n    // }, [])\n    var isServer = use_ssr_1.default().isServer;\n    var controller = react_1.useRef();\n    var attempt = react_1.useRef(0);\n    var error = react_1.useRef();\n    var hasMore = react_1.useRef(true);\n    var suspenseStatus = react_1.useRef('pending');\n    var suspender = react_1.useRef();\n    var mounted = react_1.useRef(false);\n    var expiration = react_1.useRef(Date.now() + cacheLife);\n    var _b = urs_1.default(cache.data), data = _b[0], setData = _b[1];\n    var _c = urs_1.default(defaults.loading), loading = _c[0], setLoading = _c[1];\n    var rerender = react_1.useReducer(function () { return ({}); }, [])[1];\n    // for react-native, could use https://www.npmjs.com/package/sync-storage\n    // if ([CACHE_FIRST, SWR].includes(cachePolicy) && cache.has(reqID)) {\n    //   console.log(x, 'setting data.current on rerender')\n    //   data.current = cache.get(reqID)\n    // }\n    var block = cachePolicy === NO_CACHE;\n    var makeFetch = utils_1.useDeepCallback(function (method, isBlocking) {\n        // let prevDedupeID\n        // let prevController\n        if (isBlocking === void 0) { isBlocking = block; }\n        var doFetch = function (routeOrBody, body) { return __awaiter(_this, void 0, void 0, function () {\n            var theController, _a, url, options, newData, newError, newRes, timer, timedout, promise, _b, opts, shouldRetry, _c, _d, theResponse, err_3, opts, shouldRetry, _e, _f, res;\n            return __generator(this, function (_g) {\n                switch (_g.label) {\n                    case 0:\n                        if (isServer)\n                            return [2 /*return*/]; // for now, we don't do anything on the server\n                        // const dedupeID = path + route + ':' + method\n                        // if (prevDedupeID === dedupeID && 'abort' in prevController) prevController.abort()\n                        // prevDedupeID = dedupeID\n                        // controller.current = prevController = new AbortController()\n                        controller.current = new AbortController();\n                        controller.current.signal.onabort = onAbort;\n                        theController = controller.current;\n                        return [4 /*yield*/, doFetchArgs_1.default(requestInit, method, theController, host, path, routeOrBody, body, interceptors.request)];\n                    case 1:\n                        _a = _g.sent(), url = _a.url, options = _a.options;\n                        timedout = false;\n                        console.log(\"==== \" + x + \" ====\", cache.has(reqID));\n                        // don't perform the request if there is no more data to fetch (pagination)\n                        if (perPage > 0 && !hasMore.current && !error.current)\n                            return [2 /*return*/, data.current];\n                        _g.label = 2;\n                    case 2:\n                        _g.trys.push([2, 17, 23, 24]);\n                        if (!(cache.has(reqID) && !cache.isStale && !isBlocking && [CACHE_FIRST, SWR].includes(cachePolicy))) return [3 /*break*/, 4];\n                        return [4 /*yield*/, cache.get(reqID)\n                            // newData = await cache.get(reqID)\n                            // console.log(`${x} (doFetch) newData`, newData)\n                        ];\n                    case 3:\n                        newData = _g.sent();\n                        return [3 /*break*/, 16];\n                    case 4:\n                        if (!suspense && !lazy && cachePolicy !== SWR)\n                            setLoading(true);\n                        timer = timeout && setTimeout(function () {\n                            timedout = true;\n                            theController.abort();\n                            if (onTimeout)\n                                onTimeout();\n                        }, timeout);\n                        promise = fetch(url, options);\n                        if ([CACHE_FIRST, SWR].includes(cachePolicy)) {\n                            cache.promise = promise;\n                        }\n                        return [4 /*yield*/, promise];\n                    case 5:\n                        newRes = _g.sent();\n                        return [4 /*yield*/, utils_1.tryGetData(newRes, initialData, responseType)];\n                    case 6:\n                        newData = _g.sent();\n                        newRes.data = onNewData(data.current, newData);\n                        if (!interceptors.response) return [3 /*break*/, 8];\n                        return [4 /*yield*/, interceptors.response({ response: newRes })];\n                    case 7:\n                        _b = _g.sent();\n                        return [3 /*break*/, 9];\n                    case 8:\n                        _b = newRes;\n                        _g.label = 9;\n                    case 9:\n                        newRes = _b;\n                        newData = newRes.data;\n                        utils_1.invariant('data' in newRes, 'You must have `data` field on the Response returned from your `interceptors.response`');\n                        opts = { attempt: attempt.current, response: newRes };\n                        // if we just have `retries` set with NO `retryOn` then\n                        // automatically retry on fail until attempts run out\n                        _c = !utils_1.isFunction(retryOn) && Array.isArray(retryOn) && retryOn.length < 1 && (newRes === null || newRes === void 0 ? void 0 : newRes.ok) === false\n                            // otherwise only retry when is specified\n                            || Array.isArray(retryOn) && retryOn.includes(newRes.status);\n                        if (_c) \n                        // if we just have `retries` set with NO `retryOn` then\n                        // automatically retry on fail until attempts run out\n                        return [3 /*break*/, 12];\n                        _d = utils_1.isFunction(retryOn);\n                        if (!_d) return [3 /*break*/, 11];\n                        return [4 /*yield*/, retryOn(opts)];\n                    case 10:\n                        _d = (_g.sent());\n                        _g.label = 11;\n                    case 11:\n                        _c = _d;\n                        _g.label = 12;\n                    case 12:\n                        shouldRetry = (_c) && retries > 0 && retries > attempt.current;\n                        if (!shouldRetry) return [3 /*break*/, 14];\n                        return [4 /*yield*/, retry(opts, routeOrBody, body)];\n                    case 13:\n                        theResponse = _g.sent();\n                        return [2 /*return*/, theResponse];\n                    case 14:\n                        if (Array.isArray(newData) && !!(newData.length % perPage))\n                            hasMore.current = false;\n                        if (!([CACHE_FIRST, SWR].includes(cachePolicy) && !utils_1.isEmpty(newData))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, cache.set(newData, false)];\n                    case 15:\n                        _g.sent();\n                        _g.label = 16;\n                    case 16: return [3 /*break*/, 24];\n                    case 17:\n                        err_3 = _g.sent();\n                        console.log('ERR', err_3);\n                        if (attempt.current >= retries && timedout)\n                            newError = utils_1.makeError('AbortError', 'Timeout Error');\n                        opts = { attempt: attempt.current, error: err_3 };\n                        // if we just have `retries` set with NO `retryOn` then\n                        // automatically retry on fail until attempts run out\n                        _e = !utils_1.isFunction(retryOn) && Array.isArray(retryOn) && retryOn.length < 1;\n                        if (_e) \n                        // if we just have `retries` set with NO `retryOn` then\n                        // automatically retry on fail until attempts run out\n                        return [3 /*break*/, 20];\n                        _f = utils_1.isFunction(retryOn);\n                        if (!_f) return [3 /*break*/, 19];\n                        return [4 /*yield*/, retryOn(opts)];\n                    case 18:\n                        _f = (_g.sent());\n                        _g.label = 19;\n                    case 19:\n                        _e = _f;\n                        _g.label = 20;\n                    case 20:\n                        shouldRetry = (_e) && retries > 0 && retries > attempt.current;\n                        if (!shouldRetry) return [3 /*break*/, 22];\n                        return [4 /*yield*/, retry(opts, routeOrBody, body)];\n                    case 21:\n                        res = _g.sent();\n                        return [2 /*return*/, res];\n                    case 22:\n                        if (err_3.name !== 'AbortError')\n                            newError = utils_1.makeError(err_3.name, err_3.message);\n                        return [3 /*break*/, 24];\n                    case 23:\n                        timedout = false;\n                        if (timer)\n                            clearTimeout(timer);\n                        controller.current = undefined;\n                        return [7 /*endfinally*/];\n                    case 24:\n                        if (newRes && !newRes.ok && !newError)\n                            newError = utils_1.makeError(newRes.status, newRes.statusText);\n                        if (!suspense && !lazy && cachePolicy !== SWR)\n                            setLoading(false);\n                        if (attempt.current === retries)\n                            attempt.current = 0;\n                        if (newError)\n                            onError({ error: newError });\n                        error.current = newError;\n                        return [2 /*return*/, {\n                                options: options,\n                                data: newData,\n                                error: newError,\n                                path: reqID,\n                                ok: (newRes === null || newRes === void 0 ? void 0 : newRes.ok) === true,\n                                status: newRes === null || newRes === void 0 ? void 0 : newRes.status,\n                                statusText: newRes === null || newRes === void 0 ? void 0 : newRes.statusText,\n                            }];\n                }\n            });\n        }); }; // end of doFetch()\n        var retry = function (opts, routeOrBody, body) { return __awaiter(_this, void 0, void 0, function () {\n            var delay, res;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        delay = (utils_1.isFunction(retryDelay) ? retryDelay(opts) : retryDelay);\n                        if (!(Number.isInteger(delay) && delay >= 0)) {\n                            console.error('retryDelay must be a number >= 0! If you\\'re using it as a function, it must also return a number >= 0.');\n                        }\n                        attempt.current++;\n                        if (!delay) return [3 /*break*/, 2];\n                        return [4 /*yield*/, utils_1.sleep(delay)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [4 /*yield*/, doFetch(routeOrBody, body)];\n                    case 3:\n                        res = _a.sent();\n                        return [2 /*return*/, res];\n                }\n            });\n        }); };\n        if (suspense) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return __awaiter(_this, void 0, void 0, function () {\n                    var res;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                suspender.current = doFetch.apply(void 0, args).then(function (newData) {\n                                    suspenseStatus.current = 'success';\n                                    return newData;\n                                }, function () {\n                                    suspenseStatus.current = 'error';\n                                });\n                                return [4 /*yield*/, suspender.current];\n                            case 1:\n                                res = _a.sent();\n                                rerender();\n                                return [2 /*return*/, res];\n                        }\n                    });\n                });\n            };\n        }\n        return doFetch;\n    }, [isServer, onAbort, requestInit, host, path, interceptors, cachePolicy, perPage, timeout, persist, cacheLife, onTimeout, defaults.data, onNewData, rerender, suspense]);\n    var post = react_1.useCallback(makeFetch(types_1.HTTPMethod.POST, true), [makeFetch]);\n    var request = react_1.useMemo(function () { return ({\n        get: makeFetch(types_1.HTTPMethod.GET, true),\n        post: post,\n        patch: makeFetch(types_1.HTTPMethod.PATCH, true),\n        put: makeFetch(types_1.HTTPMethod.PUT, true),\n        delete: makeFetch(types_1.HTTPMethod.DELETE, true),\n        abort: function () { return controller.current && controller.current.abort(); },\n        query: function (query, variables) { return post({ query: query, variables: variables }); },\n        mutate: function (mutation, variables) { return post({ mutation: mutation, variables: variables }); },\n        loading: loading.current,\n        error: error.current\n    }); }, [makeFetch, loading.current, error.current]);\n    var revalidate = function () { };\n    var setDataRevalidate = react_1.useCallback(function (dataOrFn, shouldRevalidate) {\n        if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n        return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                // if (currentResponse.isCached)\n                data.current = utils_1.isFunction(dataOrFn) ? dataOrFn(data.current) : dataOrFn;\n                // this will need to trigger the other components with this\n                // route to re-run their non-lazy useFetch requests\n                if (shouldRevalidate) {\n                    // TODO: revalidation\n                }\n                return [2 /*return*/];\n            });\n        });\n    }, []);\n    // onMount/onUpdate\n    react_1.useEffect(function () {\n        // if (Array.isArray(dependencies) || !mounted.current) {\n        (function () { return __awaiter(_this, void 0, void 0, function () {\n            var methodName, req, newData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        methodName = (requestInit.method || types_1.HTTPMethod.GET);\n                        req = makeFetch(methodName);\n                        return [4 /*yield*/, req()];\n                    case 1:\n                        newData = (_a.sent()).data;\n                        console.log(x + \" data.current\", data.current);\n                        console.log(x + \" newData\", newData);\n                        if (!fast_deep_equal_1.default(newData, data.current)) {\n                            if (loading.current) {\n                                data.current = newData;\n                            }\n                            else {\n                                setData(newData);\n                            }\n                        }\n                        if (loading.current)\n                            setLoading(false);\n                        // cache.errors[reqID] = error\n                        mounted.current = true;\n                        return [2 /*return*/];\n                }\n            });\n        }); })();\n        console.log(x + \" useEffect data.current\", data.current);\n        console.log(x + \" mounted.current\", mounted.current);\n        // }\n        // const currentData = data.current\n        // const initialData = cache.get(reqID) || defaults.initialData \n        // console.log('currentData', currentData)\n        // console.log('initialData', initialData)\n        // if (!isEqual(data.current, cache.get(reqID))) {\n        //   setData(cache.get(reqID))\n        // }\n        // register global cache update listener\n        var updateListener = function (shouldRevalidate, updatedData, updatedError, dedupe) {\n            if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n            if (dedupe === void 0) { dedupe = true; }\n            // update hook state\n            var newState = {};\n            var needUpdate = false;\n            if (typeof updatedData !== 'undefined' &&\n                !fast_deep_equal_1.default(data.current, updatedData)) {\n                newState.data = updatedData;\n                needUpdate = true;\n            }\n            // always update error\n            // because it can be `undefined`\n            // if (stateRef.current.error !== updatedError) {\n            //   newState.error = updatedError\n            //   needUpdate = true\n            // }\n            if (needUpdate) {\n                setData(newState.data);\n                // dispatch(newState)\n            }\n            if (shouldRevalidate) {\n                // if (dedupe) {\n                //   return softRevalidate()\n                // } else {\n                return revalidate();\n                // }\n            }\n            return false;\n        };\n        // add updater to listeners\n        cache.subscribe(updateListener);\n        // if (!cache.revalidators[reqID]) {\n        //   cache.revalidators[reqID] = [updateListener]\n        // } else {\n        //   // cache.revalidators[reqID].push(updateListener)\n        // }\n        return function () {\n            mounted.current = false;\n            cache.unsubscribe(updateListener);\n            // remove(onUpdate).from(cache.revalidators[key])\n        };\n    }, [makeFetch, reqID]);\n    if (suspense && suspender.current) {\n        if (isServer)\n            throw new Error('Suspense on server side is not yet supported! 🙅‍♂️');\n        switch (suspenseStatus.current) {\n            case 'pending':\n                throw suspender.current;\n            case 'error':\n                throw error.current;\n        }\n    }\n    console.log(x + \" END cache\", cache);\n    console.log(x + \" END cache.data\", cache.data);\n    console.log(x + \" END data.current\", data.current);\n    return Object.assign([data.current, setDataRevalidate, request], __assign(__assign({ request: request, setDataRevalidate: setDataRevalidate }, request), { loading: loading.current, data: data.current, error: error.current }));\n}\nexports.useFetch = useFetch;\nexports.default = useFetch;\n//# sourceMappingURL=useFetch.js.map"]},"metadata":{},"sourceType":"script"}